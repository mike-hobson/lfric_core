!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

module nodal_output_alg_mod

use base_mesh_config_mod,           only: geometry, &
                                          base_mesh_geometry_spherical
use constants_mod,                  only: r_def, str_max_filename, i_def
use field_mod,                      only: field_type
use finite_element_config_mod,      only: element_order
use fs_continuity_mod,              only: W0, W1, W2, W3
use log_mod,                        only: log_event,         &
                                          log_scratch_space, &
                                          LOG_LEVEL_INFO,    &
                                          LOG_LEVEL_ERROR
use multiplicity_kernel_mod,        only: multiplicity_kernel_type
use psykal_lite_mod,                only: invoke_convert_cart2sphere_vector, &
                                          invoke_pointwise_convert_xyz2llr,  &
                                          invoke_compute_dof_level_kernel
use function_space_mod,             only: function_space_type
use runtime_constants_mod,          only: get_coordinates, get_rmultiplicity
use convert_hdiv_field_kernel_mod,  only: convert_hdiv_field_kernel_type
use convert_hcurl_field_kernel_mod, only: convert_hcurl_field_kernel_type
use nodal_coordinates_kernel_mod,   only: nodal_coordinates_kernel_type

implicit none

contains

subroutine nodal_output_alg(field, chi, nodal_output, nodal_coordinates, level)

    type(field_type), intent(in)            :: field, chi(3)
    type(field_type), intent(inout)         :: nodal_output(:)
    type(field_type), intent(inout)         :: nodal_coordinates(3)
    type(field_type), intent(inout)         :: level

    ! Local variables
    type(field_type), pointer          :: nodal_rmultiplicity
    integer                            :: nodal_output_unit
    integer                            :: i, output_fs, output_dim
    type(function_space_type), pointer :: output_field_fs   => null()


    !(1) Create output fields
    output_fs = field%which_function_space()
    output_field_fs => field%get_function_space()
    if ( (output_fs == W1 .or. output_fs == W2) .and. &
         size(nodal_output) /= 3 ) then
      write( log_scratch_space, '(A)') &
        'nodal_output: 3 fields needed in actual argument for W1/W2 nodal_output'
      call log_event( log_scratch_space, log_level_error)
    end if
    do i = 1, size(nodal_output)
      nodal_output(i) = field_type( vector_space = output_field_fs )
      call invoke( setval_c(nodal_output(i), 0.0_r_def) )
    end do
    do i = 1, 3
      nodal_coordinates(i) = field_type( vector_space = output_field_fs )
    end do

    !(2) Convert field to physical nodal output & sample chi on nodal points
    ! If the field is a vector space we provide the 3 components as separate
    ! output fields
    call invoke( nodal_coordinates_kernel_type(nodal_coordinates, chi) )

    select case ( output_fs )
      case ( W0 ) 
      ! For H1 spaces no conversion is required
        call invoke( setval_X(nodal_output(1), field) )
        output_dim = 1
      case ( W1 )
        call invoke( convert_hcurl_field_kernel_type(nodal_output, field, chi) )
        output_dim = 3
      case ( W2 )
        call invoke( convert_hdiv_field_kernel_type(nodal_output, field, chi) )
        output_dim = 3
      case ( W3 ) 
        ! For L2 spaces no conversion is currently required (due to
        ! rehabilitation)
        call invoke( setval_X(nodal_output(1), field) )
        output_dim = 1
      case default
        write( log_scratch_space, '(A)') &
        'nodal_output: no field conversion has been applied'
        call log_event( log_scratch_space, log_level_info)
        call invoke( setval_X(nodal_output(1), field) )
        output_dim = 1
    end select

    if ( output_fs == W1 .or. output_fs == W2) then
      nodal_rmultiplicity => get_rmultiplicity( output_fs ) 
      do i = 1,output_dim
        call invoke( inc_X_times_Y(nodal_output(i), nodal_rmultiplicity) )
      end do
    end if

    ! (3) Convert the vector spaces to standard SI units
    ! (m/s) in orthogonal directions and, if in spherical geometry,
    !  convert the coordinate field to (longitude, latitude, radius)
    if ( geometry == base_mesh_geometry_spherical ) then
      if ( output_fs == W1 .or. output_fs == W2) then
        call invoke_convert_cart2sphere_vector(nodal_output, nodal_coordinates)         
      end if
      call invoke_pointwise_convert_xyz2llr(nodal_coordinates) 
    end if

    !(4) Compute fractional level of every dof
    level = field_type( vector_space = output_field_fs )
    call invoke_compute_dof_level_kernel(level)
  
    nullify( nodal_rmultiplicity, output_field_fs )
end subroutine nodal_output_alg

end module nodal_output_alg_mod
