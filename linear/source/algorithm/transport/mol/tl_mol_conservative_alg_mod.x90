!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains T.L. MOL routine for conservative transport of fields.

module tl_mol_conservative_alg_mod

  use constants_mod,                  only: r_def, i_def, l_def
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR
  use field_mod,                      only: field_type
  use runge_kutta_init_mod,           only: get_rk_transport_weights
  use io_config_mod,                  only: subroutine_timers
  use operator_mod,                   only: operator_type
  use timer_mod,                      only: timer
  use fem_constants_mod,              only: get_im3_div
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use transport_metadata_mod,         only: transport_metadata_type
  use flux_alg_mod,                   only: flux_alg
  use tl_flux_alg_mod,                only: tl_flux_alg
  use mesh_mod,                       only: mesh_type
  use tl_transport_runtime_collection_mod, &
                                      only: tl_transport_runtime
  use transport_runtime_alg_mod,      only: transport_runtime_type
  use transport_runtime_collection_mod, &
                                      only: get_transport_runtime
  use transport_config_mod,           only: runge_kutta_method
  use psykal_lite_mod,                only: invoke_impose_min_flux_kernel_type


  implicit none

  public  :: tl_mol_conservative_alg

  contains

  !> @brief Tangent linear transport (conservative-form) with the MOL scheme.
  !> @details Performs a whole time step transport for the tangent linear model.
  !!          This solves the conservative transport equation with the specified
  !!          options in the transport_metadata.
  !> @param[in,out] field_np1   ACTIVE  Field at the end of the time step
  !> @param[in]     field       ACTIVE  Field at the start of the transport step
  !> @param[in]     ls_field    PASSIVE Field at the start of the transport step
  !> @param[in]     direction   Direction of advection (vertical, horizontal, or 3d)
  !> @param[in]     transport_metadata
  !!                            Contains the configuration options for
  !!                            transporting these fields
  subroutine tl_mol_conservative_alg( field_np1, field, ls_field, &
                                      direction, transport_metadata )

    implicit none

    type(field_type), intent(inout)              :: field_np1
    type(field_type), intent(in)                 :: field
    type(field_type), intent(in)                 :: ls_field
    integer(i_def),   intent(in)                 :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata

    logical(l_def)                :: logspace
    integer(i_def)                :: mesh_id
    type(field_type),     pointer :: advecting_wind => null()
    type(field_type),     pointer :: ls_advecting_wind => null()
    type(field_type),     pointer :: divergence_factor => null()
    type(field_type),     pointer :: ls_divergence_factor => null()
    type(operator_type),  pointer :: div => null()
    type(field_type)              :: flux, flux_temp
    type(field_type)              :: rhs, field_n
    type(field_type)              :: field_inc
    type(field_type)              :: ls_field_np1, ls_field_n
    type(field_type), allocatable :: rk_rhs(:)
    real(r_def),      allocatable :: ak_adv(:,:)
    type(field_type), allocatable :: stored_ls_field(:,:)
    type(field_type)              :: flux_step, sum_flux
    integer(i_def)                :: stage, s
    integer(i_def)                :: nstage, substep
    logical(l_def)                :: include_div_term_with_density
    integer(i_def)                :: number_substeps
    real(r_def)                   :: dt_substep
    real(r_def)                   :: minus_dt
    logical(l_def)                :: enforce_min_value
    type(mesh_type),      pointer :: mesh => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()
    integer(i_def)                :: monotonicity

    if ( subroutine_timers ) call timer('tl_mol_conservative_alg')

    ! Get transport_runtime
    mesh => field%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Get all the stuff needed by the transport algorithm
    mesh_id = field%get_mesh_id()
    number_substeps = transport_runtime%get_number_substeps(mesh_id,direction,transport_metadata%get_splitting())
    dt_substep = transport_runtime%get_dt_substep(mesh_id,direction,transport_metadata%get_splitting())
    logspace = transport_metadata%get_log_space()
    monotonicity = transport_metadata%get_monotone()
    enforce_min_value = transport_metadata%get_enforce_min_value()
    include_div_term_with_density = transport_metadata%get_divergence_factor()
    advecting_wind => tl_transport_runtime%get_advecting_wind(mesh_id)
    ls_advecting_wind => transport_runtime%get_advecting_wind(mesh_id)
    minus_dt = - dt_substep

    call get_rk_transport_weights(nstage, ak_adv, runge_kutta_method)
    allocate( rk_rhs(nstage) )
    allocate( stored_ls_field(number_substeps,nstage) )

    do stage = 1, nstage
      call rk_rhs(stage)%initialise(field%get_function_space())
      do substep = 1, number_substeps
        call stored_ls_field(substep, stage)%initialise(field%get_function_space())
      end do
    end do

    call flux%initialise(advecting_wind%get_function_space())
    call flux_temp%initialise(advecting_wind%get_function_space())
    call flux_step%initialise(advecting_wind%get_function_space())
    call rhs%initialise(field%get_function_space())
    call field_inc%initialise(field%get_function_space())
    call field_n%initialise(field%get_function_space())
    call sum_flux%initialise(flux%get_function_space())

    call invoke( setval_c(sum_flux, 0.0_r_def) )
    call field%copy_field(field_np1)
    call field%copy_field(field_n)
    call ls_field%copy_field(ls_field_np1)
    call ls_field%copy_field(ls_field_n)

    ! Perform the number of rk-stages and substeps required
    div => get_im3_div(mesh_id)

    ! Get the div-term if required
    if ( include_div_term_with_density ) then
      call log_event('T.L. mol conservative with div factor not yet implemented', &
                     LOG_LEVEL_ERROR)
    end if

    !--------------------------------------------------------------------------!
    !                    Linearisation state
    !
    !       This calculates the values of ls_field. These are stored as an
    !       array for each substep and each RK stage to use in the perturbation
    !--------------------------------------------------------------------------!

    ! Get the div-term if required
    ! In this case we are solving: d(rho)/dt + div(div_factor*rho u) = 0
    ! Otherwise we are dealing with solving:  d(rho)/dt + div(rho u) = 0
    if ( include_div_term_with_density ) then
      ls_divergence_factor => transport_runtime%get_div_factor(mesh_id)
    end if

    do substep = 1, number_substeps

      call invoke( setval_c(flux_step, 0.0_r_def) )

      ! Include the div-term if required (this needs to be done at every sub-step)
      if ( include_div_term_with_density ) then
        call invoke( inc_X_times_Y(ls_field_np1, ls_divergence_factor) )
      end if

      do stage = 1, nstage
        ! Store values for use in the perturbation code. This is done before
        ! advecting so as to pick up the correct linearisation state
        call invoke( setval_X(stored_ls_field(substep,stage), ls_field_np1) )
        ! Build rhs depending upon type of field being advected
        ! Compute the flux using desired spatial reconstruction
        call invoke( setval_c(flux_temp, 0.0_r_def) )
        call flux_alg(flux_temp, ls_field_np1, ls_advecting_wind, &
                      direction, monotonicity, logspace=logspace)
        ! Compute: div(F)
        call invoke( dg_matrix_vector_kernel_type(rk_rhs(stage), flux_temp, div), &
                     inc_X_plus_bY(flux_step, ak_adv(nstage, stage), flux_temp) )

        ! Build rhs of Runge-Kutta scheme
        call invoke( setval_c(rhs, 0.0_r_def) )
        do s = 1, stage
          call invoke( inc_X_minus_bY(rhs, ak_adv(stage,s), rk_rhs(s)) )
        end do

        ! Update field: f = f^n - sum_k a_k * dt * rhs_k
        !                 = f^n + dt * rhs
        call invoke( aX_plus_Y(ls_field_np1, dt_substep, rhs, ls_field_n) )

      end do

      ! Compute the state at the start of the next sub-step
      ! and the sum of the fluxes of all the sub-steps
      ! field_np1 = field_n - dt*div(flux)
      call invoke( dg_matrix_vector_kernel_type(field_inc, flux_step, div), &
                   aX_plus_Y(ls_field_np1, minus_dt, field_inc, ls_field_n) )
      call ls_field_np1%copy_field(ls_field_n)

    end do ! End substepping

    ! Enforce a minimum value if required while still conservative
    if ( enforce_min_value ) then
      call log_event('T.L.: enforcing min value in mol conservative not ' // &
                     'yet implemented', LOG_LEVEL_ERROR)
    end if

    ! --------------------------------------------------------------------------
    !                    Perturbation
    !
    !   Repeat the calculation, but now for the tangent linear - adding in
    !   the values of ls_field_np1(substep,stage) obtained in the
    !   linearisation stage stage
    !---------------------------------------------------------------------------

    ! Get the div-term if required
    if ( include_div_term_with_density ) then
      divergence_factor => tl_transport_runtime%get_div_factor(mesh_id)
      call log_event('T.L.: divergence factor in mol conservative not ' // &
                     'yet implemented', LOG_LEVEL_ERROR)
    end if

    do substep = 1, number_substeps
      call invoke( setval_c(flux_step, 0.0_r_def) )

      if ( include_div_term_with_density ) then
        ! Not yet implemented, but this might be:
        ! field_np1 = ls_field_np1*div_factor + field_np1*ls_div_factor
        call log_event('T.L.: divergence factor in mol conservative not ' // &
                       'yet implemented', LOG_LEVEL_ERROR)
      end if

      do stage = 1, nstage
        ! Build rhs depending upon type of field being advected
        ! Compute the flux using desired spatial reconstruction
        call invoke( setval_c(flux_temp, 0.0_r_def) )
        call tl_flux_alg(flux_temp, field_np1, advecting_wind,              &
                         stored_ls_field(substep,stage), ls_advecting_wind, &
                         direction, logspace=logspace)
        ! Compute: div(F)
        call invoke( dg_matrix_vector_kernel_type(rk_rhs(stage), flux_temp, div), &
                     inc_X_plus_bY(flux_step, ak_adv(nstage, stage), flux_temp) )

        ! Build rhs of Runge-Kutta scheme
        call invoke( setval_c(rhs, 0.0_r_def) )
        do s = 1, stage
          call invoke( inc_X_minus_bY(rhs, ak_adv(stage,s), rk_rhs(s)) )
        end do

        ! Update field: f = f^n - sum_k a_k * dt * rhs_k
        !                 = f^n + dt * rhs
        call invoke( aX_plus_Y(field_np1, dt_substep, rhs, field_n) )

      end do ! End RK stages

      ! Compute the state at the start of the next sub-step
      ! and the sum of the fluxes of all the sub-steps
      ! field_np1 = field_n - dt*div(flux)
      call invoke( dg_matrix_vector_kernel_type(field_inc, flux_step, div), &
                   aX_plus_Y(field_np1, minus_dt, field_inc, field_n),      &
                   inc_X_plus_Y(sum_flux, flux_step) )
      call field_np1%copy_field(field_n)

    end do ! End substepping

    ! Enforce a minimum value if required while still conservative
    if ( enforce_min_value ) then
      call log_event('T.L.: enforcing min value in mol conservative not ' // &
                     'yet implemented', LOG_LEVEL_ERROR)
    end if

    if ( allocated(rk_rhs) ) deallocate(rk_rhs)
    if ( allocated(ak_adv) ) deallocate(ak_adv)
    if ( allocated(stored_ls_field) ) deallocate(stored_ls_field)
    nullify( div, advecting_wind, ls_advecting_wind )
    if ( include_div_term_with_density ) then
      nullify( divergence_factor, ls_divergence_factor )
    end if

    if ( subroutine_timers ) call timer('tl_mol_conservative_alg')

  end subroutine tl_mol_conservative_alg

end module tl_mol_conservative_alg_mod
