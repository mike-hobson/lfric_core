!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief Algorithms to produce diagnsotics
module diagnostic_alg_mod
   use constants_mod,                 only: i_def, r_def
   use finite_element_config_mod,     only: element_order
   use function_space_collection_mod, only: function_space_collection
   implicit none

   private
   public :: divergence_diagnostic_alg
   public :: pressure_diagnostic_alg
   public :: density_diagnostic_alg

contains

  subroutine divergence_diagnostic_alg(u, t, mesh_id)
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use output_alg_mod,              only: output_alg
    use runtime_constants_mod,       only: get_mass_matrix, &
                                           get_div, &
                                           w3inv_id
    use operator_mod,                only: operator_type
    use field_mod,                   only: field_type
    use fs_continuity_mod,           only: W3
    use psykal_lite_mod,             only: invoke_X_innerproduct_X
    use log_mod,                     only: log_event,         &
                                           log_scratch_space, &
                                           LOG_LEVEL_INFO

    implicit none 
    type(field_type), intent(in) :: u
    integer(i_def),   intent(in) :: t, mesh_id

    type(field_type)             :: divergence, div_u
    type(operator_type), pointer :: div => null(), m3_inv => null()
    real(r_def)                  :: l2

    divergence =  field_type( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div_u      =  field_type( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div    => get_div()
    m3_inv => get_mass_matrix(w3inv_id)
    call invoke( dg_matrix_vector_kernel_type( div_u, u, div) )

    ! Compute l2 norm of area integrated quantity
    call invoke_X_innerproduct_X(l2, div_u) 
    write( log_scratch_space, '(A,E16.8)' )  &
       'L2 of divergence =',sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )


    ! Convert to pointwise W3 field for output
    call invoke( dg_matrix_vector_kernel_type( divergence, div_u , m3_inv) )
    call output_alg('divergence',   t, divergence,   mesh_id)

  end subroutine divergence_diagnostic_alg

!=============================================================================!
  subroutine pressure_diagnostic_alg(rho, theta, t, mesh_id)
    use output_alg_mod,              only: output_alg
    use runtime_constants_mod,       only: get_mass_matrix, &
                                           get_qr, &
                                           get_coordinates, &
                                           w3inv_id
    use operator_mod,                only: operator_type
    use field_mod,                   only: field_type
    use project_pressure_kernel_mod, only: project_pressure_kernel_type
    use quadrature_mod,              only: quadrature_type
    implicit none 

    type(field_type), intent(in) :: rho, theta
    integer(i_def),   intent(in) :: t, mesh_id

    type(field_type)             :: exner
    type(operator_type), pointer :: m3_inv => null()
    type(quadrature_type)        :: qr
    type(field_type), pointer    :: chi(:) => null()

    m3_inv => get_mass_matrix(w3inv_id)
    qr = get_qr()
    chi => get_coordinates()
    exner = field_type( vector_space = rho%get_function_space() )
    call invoke( project_pressure_kernel_type( exner, rho, theta, &
                                               chi, m3_inv, qr ) )
    call output_alg('exner', t, exner, mesh_id)

  end subroutine pressure_diagnostic_alg

!=============================================================================!
  !> @details An algorithm for calculating the l2 error for the density field.
  !>          It is capable of calculating the error at each timestep by using
  !>          set_rho_alg algorithm which will return the analytic density value
  !>          at each timestep.
  !> @param[in] rho Density
  !> @param[in] timestep Timestep
  subroutine density_diagnostic_alg(rho, timestep)
    use runtime_constants_mod,       only: get_qr, &
                                           get_coordinates
    use operator_mod,                only: operator_type
    use field_mod,                   only: field_type
    use quadrature_mod,              only: quadrature_type
    use set_rho_alg_mod,             only: set_rho_alg
    use psykal_lite_mod,             only: invoke_minus_field_data,     &
                                           invoke_X_innerproduct_X
    use log_mod,                     only: log_event,         &
                                           log_scratch_space, &
                                           LOG_LEVEL_INFO

    implicit none

    type(field_type), intent(in) :: rho
    integer(i_def),   intent(in) :: timestep

    type(field_type)             :: rho_analytic
    type(field_type)             :: rho_diff
    type(operator_type), pointer :: m3_inv => null()
    type(quadrature_type)        :: qr
    type(field_type), pointer    :: chi(:) => null()
    real(r_def)                  :: l2

    qr = get_qr()
    chi => get_coordinates()

    rho_analytic = field_type( vector_space = rho%get_function_space() )
    rho_diff     = field_type( vector_space = rho%get_function_space() )
    call set_rho_alg( rho_analytic, timestep)

    call invoke_minus_field_data(rho,rho_analytic,rho_diff)

    ! Note that this method of calculating the error gives equal weighting to all
    ! the cells. It may be better to use a weighted average of the l2 error by
    ! using the cell volumes and the w3 mass matrix.
    call invoke_X_innerproduct_X(l2, rho_diff)
    write( log_scratch_space, '(A,E16.8)' )  &
       'L2 of rho difference =',sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

  end subroutine density_diagnostic_alg

end module diagnostic_alg_mod
