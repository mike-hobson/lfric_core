!-------------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queenâ€™s Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-------------------------------------------------------------------------------
!> @brief Calculates the mass fluxes in the x and y direction using the
!>        symmetric COSMIC method.
!> @details The algorithm below outputs the mass fluxes at timestep n+1 (np1)
!>          given the wind fields at timestep n and n+1 and the density field at
!>          timestep n.
module cusph_split_transport_alg_mod

  use constants_mod,                     only: r_def, i_def
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use flux_direction_mod,                only: x_direction, y_direction
  use biperiodic_deppt_config_mod,       only: method
  use subgrid_config_mod,                only: dep_pt_stencil_extent
  use psykal_lite_mod,                   only: invoke_calc_deppts,           &
                                               invoke_extract_xy,            &
                                               invoke_cosmic_departure_wind, &
                                               invoke_correct_cosmic_wind,   &
                                               invoke_set_field_scalar

  use oned_density_update_alg_mod,       only: oned_density_update_alg
  use conservative_flux_alg_mod,         only: conservative_flux_alg

  implicit none

  private
  public :: cusph_split_transport_alg

contains

  !> @brief   The algorithm returns mass flux in the x and y directions separately
  !>          with input the density field and winds at timestep n and n+1.
  !> @details The algorithm is composed of four main stages. The first stage is to 
  !>          derive the winds used to calculate the departure points for the 
  !>          Cosmic scheme. The second stage is to then calculate the departure
  !>          points.
  !>          The third and fourth stages are to perform the advective and conservative
  !>          updates respectively.
  !>          The wind fields for the Cosmic scheme need to be in finite-volume
  !>          form and in this algorithm we modify the given Piola winds to ensure
  !>          that the winds have the appropriate magnitude by dividing by detJ
  !>          at the W2 dofs and also ensuring that physically the winds have the
  !>          correct sign.
  !>          Once the appropriate winds are calculated the departure points are
  !>          then calculated.
  !> @param[in]  u_n               Winds at time level n
  !> @param[in]  u_np1             Winds at time level n+1
  !> @param[in]  rho               Density at time level n
  !> @param[in]  chi               Coordinate field array
  !> @param[in]  cell_orientation  Orientation of cells held in W3 field
  !> @param[in]  mesh_id           mesh id
  !> @param[out] mass_flux_x       Mass fluxes in x direction used to update density
  !> @param[out] mass_flux_y       Mass fluxes in y direction used to update density
  !> @param[in]  detj_at_w2        Detj values at W2 dof locations
  subroutine cusph_split_transport_alg( u_n,                &
                                        u_np1,              &
                                        rho,                &
                                        chi,                &
                                        cell_orientation,   &
                                        mesh_id,            &
                                        mass_flux_x,        &
                                        mass_flux_y,        &
                                        detj_at_w2 )

    implicit none

    type(field_type),    intent(in)     :: u_n
    type(field_type),    intent(in)     :: u_np1
    type(field_type),    intent(in)     :: rho
    type(field_type),    intent(in)     :: chi(3)
    type(field_type),    intent(in)     :: cell_orientation
    integer(i_def),      intent(in)     :: mesh_id
    type(field_type),    intent(inout)  :: mass_flux_x
    type(field_type),    intent(inout)  :: mass_flux_y
    type(field_type),    intent(in)     :: detj_at_w2

    type( field_type ) :: dep_pts_x, dep_pts_y
    type( field_type ) :: rho_n, rho_adv_x, rho_adv_y, rho_hat_adv_x, rho_hat_adv_y
    type( field_type ) :: rho_x, rho_y
    type( field_type ) :: u_x_fem_n, u_y_fem_n, u_x_fem_np1, u_y_fem_np1
    type( field_type ) :: dep_wind_x_n, dep_wind_y_n
    type( field_type ) :: dep_wind_x_np1, dep_wind_y_np1

    type( field_type ) :: corrected_dep_wind_x_n, corrected_dep_wind_y_n
    type( field_type ) :: corrected_dep_wind_x_np1, corrected_dep_wind_y_np1

    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()

    w3_fs => rho%get_function_space()
    w2_fs => u_n%get_function_space()

    dep_pts_x          = field_type( vector_space = w2_fs )
    dep_pts_y          = field_type( vector_space = w2_fs )

    dep_wind_x_n   = field_type( vector_space = w2_fs )
    dep_wind_y_n   = field_type( vector_space = w2_fs )
    dep_wind_x_np1   = field_type( vector_space = w2_fs )
    dep_wind_y_np1   = field_type( vector_space = w2_fs )

    corrected_dep_wind_x_n   = field_type( vector_space = w2_fs )
    corrected_dep_wind_y_n   = field_type( vector_space = w2_fs )
    corrected_dep_wind_x_np1   = field_type( vector_space = w2_fs )
    corrected_dep_wind_y_np1   = field_type( vector_space = w2_fs )

    rho_adv_x          = field_type( vector_space = w3_fs )
    rho_adv_y          = field_type( vector_space = w3_fs )
    rho_hat_adv_x      = field_type( vector_space = w3_fs )
    rho_hat_adv_y      = field_type( vector_space = w3_fs )
    rho_x              = field_type( vector_space = w3_fs )
    rho_y              = field_type( vector_space = w3_fs )
    u_x_fem_n          = field_type( vector_space = w2_fs )
    u_y_fem_n          = field_type( vector_space = w2_fs )
    u_x_fem_np1        = field_type( vector_space = w2_fs )
    u_y_fem_np1        = field_type( vector_space = w2_fs )

    ! Separate finite-element wind field into x and y components
    call invoke( name = "Initialise wind fields",    & 
                 setval_c(u_x_fem_n,   -99.0_r_def), &
                 setval_c(u_y_fem_n,   -99.0_r_def), &
                 setval_c(u_x_fem_np1, -99.0_r_def), &
                 setval_c(u_y_fem_np1, -99.0_r_def) )

    call invoke_extract_xy(u_x_fem_n,u_y_fem_n,u_n,cell_orientation)
    call invoke_extract_xy(u_x_fem_np1,u_y_fem_np1,u_np1,cell_orientation)

    ! Calculate the departure wind used for calculating departure points
    call invoke_cosmic_departure_wind(dep_wind_x_n, dep_wind_y_n, u_x_fem_n, u_y_fem_n, chi, x_direction)
    call invoke_cosmic_departure_wind(dep_wind_x_n, dep_wind_y_n, u_x_fem_n, u_y_fem_n, chi, y_direction)
    call invoke_cosmic_departure_wind(dep_wind_x_np1, dep_wind_y_np1, u_x_fem_np1, u_y_fem_np1, chi, x_direction)
    call invoke_cosmic_departure_wind(dep_wind_x_np1, dep_wind_y_np1, u_x_fem_np1, u_y_fem_np1, chi, y_direction)

    call invoke_correct_cosmic_wind(corrected_dep_wind_x_n,corrected_dep_wind_y_n,    &
                                dep_wind_x_n,dep_wind_y_n,cell_orientation,x_direction)
    call invoke_correct_cosmic_wind(corrected_dep_wind_x_n,corrected_dep_wind_y_n,    &
                                dep_wind_x_n,dep_wind_y_n,cell_orientation,y_direction)
    call invoke_correct_cosmic_wind(corrected_dep_wind_x_np1,corrected_dep_wind_y_np1, &
                                dep_wind_x_np1,dep_wind_y_np1,cell_orientation,x_direction)
    call invoke_correct_cosmic_wind(corrected_dep_wind_x_np1,corrected_dep_wind_y_np1, &
                                dep_wind_x_np1,dep_wind_y_np1,cell_orientation,y_direction)

    ! Calculate the departure points for W2 nodal points at lowest order
    call invoke_set_field_scalar(-99.0_r_def,dep_pts_x)
    call invoke_set_field_scalar(-99.0_r_def,dep_pts_y)
    call invoke_calc_deppts(corrected_dep_wind_x_n, corrected_dep_wind_x_np1, dep_pts_x,   &
                   cell_orientation, x_direction, method, dep_pt_stencil_extent)
    call invoke_calc_deppts(corrected_dep_wind_y_n, corrected_dep_wind_y_np1, dep_pts_y,   &
                   cell_orientation, y_direction, method, dep_pt_stencil_extent)

    ! Perform two 1D advective updates in the x and y directions (horizontal)
    call oned_density_update_alg(x_direction, u_n, dep_pts_x,       &
                                  cell_orientation, detj_at_w2, rho, rho_adv_x)
    call oned_density_update_alg(y_direction, u_n, dep_pts_y,       &
                                  cell_orientation, detj_at_w2, rho, rho_adv_y)

    ! Average the two advective density updates with the density at timestep level n
    call invoke( name = "Average Rho and init Mass fluxes",                       &
                 aX_plus_bY(rho_hat_adv_x, 0.5_r_def, rho, 0.5_r_def, rho_adv_x), &
                 aX_plus_bY(rho_hat_adv_y, 0.5_r_def, rho, 0.5_r_def, rho_adv_y), &

    ! Calculate separately the conservative fluxes in the x and y directions (horizontal)
                 setval_c(mass_flux_x, 0.0_r_def),                                &
                 setval_c(mass_flux_y, 0.0_r_def) )

    call conservative_flux_alg(u_n, dep_pts_x, dep_pts_y,             &
                           cell_orientation, rho_hat_adv_x, rho_hat_adv_y, mass_flux_x, mass_flux_y )

  end subroutine cusph_split_transport_alg

end module cusph_split_transport_alg_mod
