!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> @brief Algorithms to produce diagnsotics
module diagnostic_alg_mod
   use constants_mod,                 only: i_def, r_def
   use finite_element_config_mod,     only: element_order
   use function_space_collection_mod, only: function_space_collection
   use output_config_mod,             only : write_nodal_output, &
                                             write_xios_output
   use io_mod,                        only : output_nodal, &
                                             output_xios_nodal, &
                                             xios_write_field_face
   implicit none

   private
   public :: divergence_diagnostic_alg
   public :: pressure_diagnostic_alg
   public :: density_diagnostic_alg

contains

  subroutine divergence_diagnostic_alg(u, t, mesh_id)
    use dg_matrix_vector_kernel_mod, only: dg_matrix_vector_kernel_type
    use runtime_constants_mod,       only: get_mass_matrix, &
                                           get_div, &
                                           w3inv_id
    use operator_mod,                only: operator_type
    use field_mod,                   only: field_type, write_interface
    use fs_continuity_mod,           only: W3
    use log_mod,                     only: log_event,         &
                                           log_scratch_space, &
                                           LOG_LEVEL_INFO

    implicit none 
    type(field_type), intent(in) :: u
    integer(i_def),   intent(in) :: t, mesh_id

    type(field_type)             :: divergence, div_u
    type(operator_type), pointer :: div => null(), m3_inv => null()
    real(r_def)                  :: l2

    procedure(write_interface), pointer  :: tmp_ptr

    divergence =  field_type( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div_u      =  field_type( vector_space = function_space_collection%get_fs(mesh_id,element_order, W3) )
    div    => get_div()
    m3_inv => get_mass_matrix(w3inv_id)
    call invoke( dg_matrix_vector_kernel_type( div_u, u, div ), &

    ! Compute l2 norm of area integrated quantity
                 X_innerproduct_X( l2, div_u ) )
    write( log_scratch_space, '(A,E16.8)' )  &
       'L2 of divergence =',sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )


    ! Convert to pointwise W3 field for output
    call invoke( dg_matrix_vector_kernel_type( divergence, div_u , m3_inv ) )

    ! Check what output options have been requested and call them
 
    if (write_nodal_output) then
      call output_nodal('divergence',   t, divergence,   mesh_id)
    end if 

    if (write_xios_output) then
      !If using XIOS, we need to set the field IO method appropriately
      tmp_ptr => xios_write_field_face
      call divergence%set_write_field_behaviour(tmp_ptr)
      if (t == 0) then
        call divergence%write_field('init_divergence')
      else
        call divergence%write_field('divergence')
      end if
    end if 

  end subroutine divergence_diagnostic_alg

!=============================================================================!
  subroutine pressure_diagnostic_alg(rho, theta, t, mesh_id)
    use runtime_constants_mod,       only: get_mass_matrix, &
                                           get_qr, &
                                           get_coordinates, &
                                           w3inv_id
    use operator_mod,                only: operator_type
    use field_mod,                   only: field_type, write_interface
    use project_pressure_kernel_mod, only: project_pressure_kernel_type
    use quadrature_mod,              only: quadrature_type
    implicit none 

    type(field_type), intent(in) :: rho, theta
    integer(i_def),   intent(in) :: t, mesh_id

    type(field_type)             :: exner
    type(operator_type), pointer :: m3_inv => null()
    type(quadrature_type)        :: qr
    type(field_type), pointer    :: chi(:) => null()

    procedure(write_interface), pointer  :: tmp_ptr

    m3_inv => get_mass_matrix(w3inv_id)
    qr = get_qr()
    chi => get_coordinates()
    exner = field_type( vector_space = rho%get_function_space() )
    call invoke( project_pressure_kernel_type( exner, rho, theta, &
                                               chi, m3_inv, qr ) )

    ! Check what output options have been requested and call them
 
    if (write_nodal_output) then
      call output_nodal('exner',   t, exner,   mesh_id)
    end if 

    if (write_xios_output) then
      ! If using XIOS, we need to set the field IO method appropriately
      tmp_ptr => xios_write_field_face
      call exner%set_write_field_behaviour(tmp_ptr)
      if (t == 0) then
        call exner%write_field('init_exner')
      else
        call exner%write_field('exner')
      end if
    end if 


  end subroutine pressure_diagnostic_alg

!=============================================================================!
  !> @details An algorithm for calculating the l2 error for the density field.
  !>          It is capable of calculating the error at each timestep by using
  !>          set_rho_alg algorithm which will return the analytic density value
  !>          at each timestep.
  !> @param[in] rho Density
  !> @param[in] timestep Timestep
  subroutine density_diagnostic_alg(rho, timestep)
    use runtime_constants_mod,       only: get_qr, &
                                           get_coordinates
    use operator_mod,                only: operator_type
    use field_mod,                   only: field_type
    use quadrature_mod,              only: quadrature_type
    use set_rho_alg_mod,             only: set_rho_alg
    use log_mod,                     only: log_event,         &
                                           log_scratch_space, &
                                           LOG_LEVEL_INFO

    implicit none

    type(field_type), intent(in) :: rho
    integer(i_def),   intent(in) :: timestep

    type(field_type)             :: rho_analytic
    type(field_type)             :: rho_diff
    type(operator_type), pointer :: m3_inv => null()
    type(quadrature_type)        :: qr
    type(field_type), pointer    :: chi(:) => null()
    real(r_def)                  :: l2

    qr = get_qr()
    chi => get_coordinates()

    rho_analytic = field_type( vector_space = rho%get_function_space() )
    rho_diff     = field_type( vector_space = rho%get_function_space() )
    call set_rho_alg( rho_analytic, timestep)

    call invoke( X_minus_Y( rho_diff, rho, rho_analytic ), &
    ! Note that this method of calculating the error gives equal weighting to all
    ! the cells. It may be better to use a weighted average of the l2 error by
    ! using the cell volumes and the w3 mass matrix.
                 X_innerproduct_X( l2, rho_diff ) )
    write( log_scratch_space, '(A,E16.8)' )  &
       'L2 of rho difference =',sqrt(l2)
    call log_event( log_scratch_space, LOG_LEVEL_INFO )

  end subroutine density_diagnostic_alg

end module diagnostic_alg_mod
