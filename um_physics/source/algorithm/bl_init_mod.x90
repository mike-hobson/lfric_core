!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!> @brief initialisation of things needed by BL scheme

module bl_init_mod

  use constants_mod,         only : i_um, r_def
  implicit none

contains

  subroutine bl_init(theta_in_wth, tstar_2d, zh_2d, z0msea_2d)

    ! UM modules
    use allocate_jules_arrays_mod, only: allocate_jules_arrays
    use ancil_info, only: ssi_pts, sea_pts, sice_pts,                      &
         sice_pts_ncat, ssi_index, sea_index, sice_index,                  &
         sice_index_ncat, fssi_ij, sea_frac, sice_frac, sice_frac_ncat
    use atm_fields_bounds_mod, only: atm_fields_bounds_init
    use bl_option_mod, only: i_bl_vn, sbl_op, ritrans,                     &
         cbl_op, lambda_min_nml, l_bl_mix_qcf, local_fa, keep_ri_fa,       &
         sg_orog_mixing, fric_heating, idyndiag,                           &
         zhloc_depth_fac, flux_grad, entr_smooth_dec,                      &
         relax_sc_over_cu, bl_res_inv, blending_option,                    &
         a_ent_shr_nml, alpha_cd, puns, pstb, nl_bl_levels, kprof_cu
    use cloud_inputs_mod, only: i_cld_vn, forced_cu, i_rhcpt, i_cld_area,  &
         l_fixbug_pc2_mixph
    use cv_run_mod, only: icvdiag, cvdiag_inv, cvdiag_sh_wtest,            &
         limit_pert_opt, tv1_sd_opt, iconv_congestus, iconv_deep,          &
         ent_fac_dp, cldbase_opt_dp, cldbase_opt_sh, w_cape_limit
    use dyn_coriolis_mod, only: f3_at_u
    use dynamics_input_mod, only: numcycles
    use jules_sea_seaice_mod, only: nice_use, iseasurfalg, emis_sea,       &
         seasalinityfactor, charnock, nice
    use jules_soil_mod, only: dzsoil, dzsoil_io
    use jules_surface_mod, only: l_epot_corr, cor_mo_iter, iscrntdiag,     &
         isrfexcnvgust
    use jules_surface_types_mod, only: nnpft, npft, nnvg, ntype, urban,    &
         lake, soil, ice
    use level_heights_mod, only: r_theta_levels, r_rho_levels, eta_theta_levels
    use model_domain_mod, only: model_type
    use nlsizes_namelist_mod, only: model_levels, bl_levels, row_length,   &
         rows, land_field, ntiles, sm_levels, tr_vars
    use planet_constants_mod, only: set_planet_constants, i_planet,        &
         cp_um => cp, cv_um => cv, g, kappa_um => kappa, omega_um => omega,&
         p_zero_um => p_zero, planet_radius, r, pref, two_omega,           &
         recip_p_zero, recip_kappa, grcp, lcrcp, lfrcp, lsrcp, recip_a2,   &
         g_over_r
    use water_constants_mod, only: lc, lf
    use timestep_mod, only: timestep
    use tuning_segments_mod, only: bl_segment_size

    ! LFRic modules
    use field_mod, only : field_type, field_proxy_type
    use planet_config_mod, only: cp, cv, gravity, kappa, omega, p_zero,    &
         radius, rd
    use mesh_mod, only : mesh_type
    use timestepping_config_mod, only: dt

    implicit none

    type( field_type ), intent( in ) :: theta_in_wth
    type( field_type ), intent( inout ) :: tstar_2d, zh_2d, z0msea_2d
    type( field_proxy_type )  :: theta_in_wth_proxy
    type( mesh_type ), pointer :: mesh => null()

    ! loop counters
    integer :: i,j,l,n

    theta_in_wth_proxy = theta_in_wth%get_proxy()

    ! set up various dimensions for a single column sea point
    model_levels = theta_in_wth_proxy%vspace%get_nlayers()
    bl_levels = model_levels-1
    row_length=1
    rows=1
    land_field=0
    ntiles=1
    sm_levels=1
    nice=1
    nice_use=1
    tr_vars=0

    ! set up constants for earth
    i_planet=3
    call set_planet_constants()
    ! over-write with LFRic constants
    cp_um = cp
    cv_um = cv
    g = gravity
    kappa_um = kappa
    omega_um = omega
    p_zero_um = p_zero
    planet_radius = radius
    r = rd
    ! re-derive relevant derived constants
    pref = p_zero
    two_omega     = 2.0*omega
    recip_p_zero  = 1.0/pref
    recip_kappa   = 1.0/kappa
    grcp          = g/cp
    lcrcp         = lc/cp
    lfrcp         = lf/cp
    lsrcp         = (lc+lf)/cp
    recip_a2      = 1.0/(planet_radius*planet_radius)
    g_over_r      = g/r

    ! set up array sizes for a single column model
    model_type=5
    call atm_fields_bounds_init( 0_i_um, 0_i_um, 0_i_um, &
                                 0_i_um, row_length, rows,rows,  &
                                 model_levels, bl_levels, model_levels )

    ! allocate jules stuff
    nnpft=5
    npft=5
    nnvg=4
    ntype=9
    urban=6
    lake=7
    soil=8
    ice=9
    call allocate_jules_arrays(land_field,ntiles,sm_levels,nice_use,nice_use)
    dzsoil => dzsoil_io(1:sm_levels)

    ! model timestep
    timestep=dt

    ! BL options
    i_bl_vn=3
    sbl_op=6
    ritrans=0.1
    cbl_op=2
    lambda_min_nml=40.0
    l_bl_mix_qcf=.true.
    local_fa=1
    keep_ri_fa=1
    sg_orog_mixing=0
    fric_heating=1
    idyndiag=4
    zhloc_depth_fac=0.3
    flux_grad=0
    entr_smooth_dec=0
    relax_sc_over_cu=0
    kprof_cu=0
    bl_res_inv=0
    blending_option=0
    a_ent_shr_nml=5.0
    allocate(alpha_cd(bl_levels))
    alpha_cd=1.5
    alpha_cd(1)=2.0
    puns=0.5
    pstb=2.0
    nl_bl_levels=bl_levels

    ! convection options
    icvdiag=1
    cvdiag_inv=0
    cvdiag_sh_wtest=0.02
    limit_pert_opt=2
    tv1_sd_opt=2
    iconv_congestus=0
    iconv_deep=1
    ent_fac_dp=1.13
    cldbase_opt_dp=3
    cldbase_opt_sh=0
    w_cape_limit=0.3

    ! cloud options
    i_cld_vn=0
    i_rhcpt=0
    forced_cu=0
    i_cld_area=0
    l_fixbug_pc2_mixph=.true.

    ! dynamics options
    numcycles=1

    ! tuning segment sizes
    bl_segment_size=16

    ! jules options
    charnock=0.018
    emis_sea=0.985
    iseasurfalg=1
    seasalinityfactor=0.98
    cor_mo_iter=3
    iscrntdiag=2
    isrfexcnvgust=1
    l_epot_corr=.true.

    ! arrays that should be allocated at startup
    allocate(f3_at_u(row_length,rows))
    allocate(r_theta_levels(row_length,rows,0:model_levels))
    allocate(r_rho_levels(row_length,rows,model_levels))
    allocate(eta_theta_levels(0:model_levels))

    ! BL prognostics - initialise
    call invoke( setval_c(tstar_2d, 300.0_r_def))
    call invoke( setval_c(zh_2d, 1000.0_r_def))
    call invoke( setval_c(z0msea_2d, 1.5e-4_r_def))

    !-----------------------------------------------------------------------
    ! Set up index for sea and sea-ice
    !
    ! This code is copied from atmos_physics1 and has been adapted
    ! for a sea-point only - no land or sea-ice
    !
    ! It will need re-writing!
    !-----------------------------------------------------------------------
    ssi_pts = 0
    ssi_index(:)=0
    DO j=1,rows
      DO i=1,row_length
        ssi_pts=ssi_pts + 1
        ssi_index(ssi_pts) = (j-1)*row_length + i
        fssi_ij(i,j)=1.0
      END DO
    END DO

    !-----------------------------------------------------------------------
    ! Allocate space for and initialise sea and sea-ice indices.
    !-----------------------------------------------------------------------
    sea_pts = 0
    sice_pts = 0
    sea_index(:)=0
    sice_index(:)=0
    sice_frac(:)=0.0
    sea_frac(:)=0.0
    DO l=1,ssi_pts
      j=(ssi_index(l)-1)/row_length + 1
      i = ssi_index(l) - (j-1)*row_length
      IF (ssi_index(l) > 0) THEN
        sea_pts=sea_pts+1
        sea_index(sea_pts)=l
        sea_frac(l)=1.0 - sice_frac(l)
      END IF
    END DO

    ! NOTE these settings use NICE_USE not NICE so are suitable for use here and
    ! in the explicit part of the surface exchange code.  They are then updated
    ! using NICE before the call to the implicit part of the surface exchange
    ! code
    sice_pts_ncat(:)=0
    sice_index_ncat(:,:)=0
    sice_frac_ncat(:,:)=0.0

  end subroutine bl_init

end module bl_init_mod
