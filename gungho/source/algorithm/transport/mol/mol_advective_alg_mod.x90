!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains routine for advecting (advection-form) fields using MOL.

module mol_advective_alg_mod

  use constants_mod,                  only: r_def, i_def, l_def
  use field_mod,                      only: field_type
  use runge_kutta_init_mod,           only: get_rk_transport_weights
  use timer_mod,                      only: timer
  use advective_increment_alg_mod,    only: advective_increment_alg
  use mesh_mod,                       only: mesh_type
  use transport_metadata_mod,         only: transport_metadata_type
  use transport_runtime_alg_mod,      only: transport_runtime_type
  use transport_runtime_collection_mod, &
                                      only: get_transport_runtime
  use transport_config_mod,           only: runge_kutta_method
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type

  implicit none

  public  :: mol_advective_alg

contains

  !> @brief Advecting a field with the MOL scheme.
  !> @details Performs a whole time step advection, i.e., solving the advection
  !!          (non-conservative) equation with the specified options
  !!          in the transport_metadata.
  !> @param[in,out] field_np1   Field at the end of the time step
  !> @param[in]     field       Field at the start of the transport step
  !> @param[in]     direction   Direction of advection (vertical, horizontal, or 3d)
  !> @param[in]     transport_metadata
  !!                         Contains the configuration options for transporting these fields
  subroutine mol_advective_alg( field_np1, field, direction, transport_metadata)

    implicit none

    type(field_type),              intent(inout) :: field_np1
    type(field_type),              intent(in)    :: field
    integer(i_def),                intent(in)    :: direction
    type(transport_metadata_type), intent(in)    :: transport_metadata

    logical(l_def)   :: logspace
    integer(i_def)   :: monotonicity
    type(field_type) :: rhs, field_n
    integer(i_def)   :: mesh_id

    type(field_type), pointer     :: advecting_wind => null()
    type(field_type), allocatable :: rk_rhs(:)
    integer(i_def)                :: stage, s
    integer(i_def)                :: nstage, substeps
    real(r_def), allocatable      :: ak_adv(:,:)
    type(field_type)              :: advection_inc
    type(mesh_type),      pointer :: mesh => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    integer(i_def) :: number_substeps
    real(r_def)    :: dt_substep
    logical(l_def) :: enforce_min_value
    real(r_def)    :: min_value

    ! get the stuff needed by the advection algorithm
    mesh_id = field%get_mesh_id()

    ! Get transport_runtime
    mesh => field%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    number_substeps = transport_runtime%get_number_substeps(mesh_id,direction,transport_metadata%get_splitting())
    dt_substep      = transport_runtime%get_dt_substep(mesh_id,direction,transport_metadata%get_splitting())
    advecting_wind  => transport_runtime%get_advecting_wind(mesh_id)

    logspace     = transport_metadata%get_log_space()
    monotonicity = transport_metadata%get_monotone()
    enforce_min_value = transport_metadata%get_enforce_min_value()

    call rhs%initialise(field%get_function_space())
    call field_n%initialise(field%get_function_space())
    call advection_inc%initialise(field%get_function_space())

    call field%copy_field(field_np1)
    call field%copy_field(field_n)

    call get_rk_transport_weights(nstage, ak_adv, runge_kutta_method)
    allocate( rk_rhs(nstage) )

    do stage = 1, nstage
      call rk_rhs(stage)%initialise(field%get_function_space())
    end do

    ! Perform the number of rk-stages and substeps required
    do substeps = 1, number_substeps

      call invoke( setval_c(advection_inc, 0.0_r_def) )

      do stage = 1, nstage
        ! Build rhs depending upon type of field being advected
        ! Compute: - u.grad(f)
        call advective_increment_alg(rk_rhs(stage), field_np1,       &
                                     advecting_wind, dt_substep,     &
                                     direction, monotonicity,        &
                                     logspace=logspace               )

        call invoke( setval_c(rhs, 0.0_r_def) )
        do s = 1, stage
          call invoke( inc_X_minus_bY(rhs, ak_adv(stage,s), rk_rhs(s)) )
        end do
        ! Update field: f = f^n - sum_k a_k * dt * rhs_k
        !               f = f^n + dt_substep*rhs
        call invoke( aX_plus_Y(field_np1, dt_substep, rhs, field_n), &
        ! Add increment from this stage to the advection increment
                     inc_X_minus_bY(advection_inc,                   &
                                    ak_adv(nstage, stage), rk_rhs(stage)) )

      end do  ! end rk-stages

      ! Compute the initial state (field_np1) for the next substep
      call invoke( aX_plus_Y(field_np1, dt_substep, advection_inc, field_n) )
      call field_np1%copy_field(field_n)

    end do

    ! Enforce a min value if required
    if ( enforce_min_value ) then
       min_value = transport_metadata%get_min_value()
       call invoke( enforce_lower_bound_kernel_type(field_np1, min_value) )
    end if

    nullify( advecting_wind, mesh, transport_runtime )

    if ( allocated(rk_rhs) ) deallocate(rk_rhs)
    if ( allocated(ak_adv) ) deallocate(ak_adv)

  end subroutine mol_advective_alg

end module mol_advective_alg_mod
